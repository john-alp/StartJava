017 Введение в многопоточность в Java
    - параллельное выполнение методо и программ. Потоки борятся за процессорное время, то есть они не синхронизированны
     extends от класс Thread или implements от интерфейса Runnable, в своем классе переопределяем метод run, а запускаем в      main методом start (не run!)

018 Ключевое слово volatile
    Для гарантированного выполнения переменной в случае её изменения. Что бы эта переменная не попала в кэш процессора.
    private volatile boolean running
    Используется тогда, когда в одном потоке записанна эта переменная, а второй поток читает из него

019 Ключевое слово synchronized I часть
    Синхронизирует работу потоков. В методе класса обьект который мы используем,
    пишем - public synchronized void .. и этот метод может использовать только один поток.
    Остальные потоки ждут своей очереди.

020 Ключевое слово synchronized II часть
    synchronized можно использовать только на объекте, для этого нужно создать Object lock = new Object(); (правило хорошего тона использовать такие объекты для синхранизации потоков) и использовать для синхронизации потоков несколько таких объектов.
    Если synchronized использовать как ключевое слово, то он использует объект this
     (т.е. объект, который его вызвал).
    synchronized (lock){}

021 Пул потоков Thread pool
     Используем ExecutorService для создания пула с необходимым количеством потоков
     Мы взяли два работника, которые будут носить коробки и которые не будут драться за одну ту же коробку.

022 Паттерн producer - consumer I часть
    Producer создаёт что-то, а consumer "потребляет" (два разных потока, работающих параллельно)

023 Методы wait и notify
    Вызываются только на синхронизированных потоках. По умолчанию вызываются на объекте this, если синхронизация на другом объекте надо явно указывать на каком вызывать. wait() запускается, отдает монитор и ждет запуска notify(); главное чтобы объекты были одинаковые.

024 Паттерн producer - consumer II часть
    В этой лекции мы создали паттерн producer - consumer с помощью низкоуровневых методов wait и notify
    Обьект на котором синхронизируемся толжен быть константой

025 Класс CountDownLatch
    дословно переводится как "Обратный Отсчет Защелка" в качестве переменной передается число - сколько отсчитывать обратно. Класс с синхронизированными потоками.

026 Класс ReentrantLock
    Используетс вместо ключевого слова синхронайзд, Это класс имплементирующий интерфейс Lock. Использовали методы lock and unlock

027 Семафор Semaphore
    Ограничивает доступ к ресурсам потоками

028 Взаимная блокировка Deadlock
029 Прерывание потоков
    Мы можем остановить один поток из другого потока, но для этого нужно в потоке, который хотим остановить, предусмотреть прочтение этой остановки
030 Callable и Future
    Callable в отличие от Runable возвращает какое-то значение (например можно предуссотреть обработку какого-то исключения и с помощью Future и метода .get поймать это исключение и вывести на экран (.getMessage)
